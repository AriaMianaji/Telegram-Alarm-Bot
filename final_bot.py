# -*- coding: utf-8 -*-
"""final bot

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rSjdNyEVzQN80fG8RkaHcGWREi8RURcV
"""

import logging
import os
import random
from datetime import datetime, time
import pytz
import asyncio

from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

# --- Configuration ---
# Reads the token from the server's environment variables
TOKEN = "TELEGRAM_BOT_TOKEN"
BOT_TIMEZONE = pytz.timezone("Asia/Tehran")

# --- Constants ---
GET_TIME = 0 # State for the conversation

# --- Logging Setup ---
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Question Repository ---
def generate_questions():
    """Generates a list of 100 simple-to-intermediate math questions in Farsi."""
    questions = []
    for _ in range(40):
        a, b = random.randint(10, 150), random.randint(10, 150)
        questions.append({"question": f"🧠 حاصل {a} + {b} چیست؟", "answer": str(a + b)})
    for _ in range(30):
        a, b = random.randint(2, 12), random.randint(3, 15)
        questions.append({"question": f"🧠 حاصل {a} × {b} چیست؟", "answer": str(a * b)})
    for _ in range(30):
        a, b, c = random.randint(2, 10), random.randint(2, 10), random.randint(10, 50)
        questions.append({"question": f"🧠 حاصل ({a} × {b}) + {c} چیست؟", "answer": str(a * b + c)})
    random.shuffle(questions)
    return questions

MATH_QUESTIONS = generate_questions()

# --- ALARM CHECKER LOGIC ---
async def send_quiz_challenge(chat_id: int, context: ContextTypes.DEFAULT_TYPE):
    """Starts the quiz for a specific user."""
    user_id = chat_id
    user_specific_data = context.application.user_data[user_id]

    user_specific_data['quiz_active'] = True
    user_specific_data['questions_asked'] = 1
    user_specific_data['wrong_answers'] = 0

    question_data = random.choice(MATH_QUESTIONS)
    user_specific_data['current_answer'] = question_data["answer"]

    await context.bot.send_message(
        chat_id=chat_id,
        text=f"⏰ وقت بیدار شدن است! به این سوال پاسخ دهید:\n\n{question_data['question']}"
    )

async def alarm_checker(application: Application):
    """This task runs in the background, checking the time every minute."""
    while True:
        now = datetime.now(BOT_TIMEZONE)
        current_time_str = now.strftime("%H:%M")

        if alarms_to_trigger := application.bot_data.get(current_time_str, []):
            print(f"DEBUG: Found alarms for {current_time_str}!")
            for chat_id in alarms_to_trigger:
                asyncio.create_task(send_quiz_challenge(chat_id, ContextTypes.DEFAULT_TYPE(application, chat_id=chat_id)))

            application.bot_data[current_time_str] = []

        await asyncio.sleep(60)

# --- Core Bot Functions ---
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text("👋 به ربات آلارمی خوش آمدید!\n\nبرای تنظیم آلارم روزانه از دستور /setalarm استفاده کنید.")

async def set_alarm_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Starts the conversation to set an alarm."""
    await update.message.reply_text("⏰ لطفاً ساعت آلارم را با فرمت HH:MM یا H:MM برای من ارسال کنید (مثلاً 08:00 یا 8:00).")
    return GET_TIME

async def get_time_from_user(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Saves an alarm after receiving the time from the user."""
    user_input = update.message.text.strip()
    chat_id = update.message.chat_id

    try:
        hour_str, minute_str = user_input.split(':')
        hour = int(hour_str)
        minute = int(minute_str)

        if not (0 <= hour <= 23 and 0 <= minute <= 59):
            raise ValueError("Time out of range.")

        alarm_time_str = f"{hour:02d}:{minute:02d}"

        if alarm_time_str not in context.bot_data:
            context.bot_data[alarm_time_str] = []

        if chat_id not in context.bot_data[alarm_time_str]:
            context.bot_data[alarm_time_str].append(chat_id)
            print(f"DEBUG: Alarm set for {chat_id} at {alarm_time_str}")
            await update.message.reply_text(f"✅ موفقیت! آلارم شما برای ساعت {alarm_time_str} (به وقت تهران) تنظیم شد.")
        else:
            await update.message.reply_text("شما قبلاً یک آلارم برای این ساعت تنظیم کرده‌اید.")

    except (ValueError, IndexError):
        await update.message.reply_text("❌ فرمت نامعتبر است. لطفاً از فرمت HH:MM یا H:MM استفاده کنید (مثلاً 07:45 یا 7:45).")
        return GET_TIME

    return ConversationHandler.END

async def cancel_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancels the current conversation and clears any alarms."""
    chat_id = update.message.from_user.id
    for time_str, chat_ids in list(context.bot_data.items()):
        if chat_id in chat_ids:
            chat_ids.remove(chat_id)

    await update.message.reply_text("عملیات لغو شد و تمام آلارم‌های شما پاک شد.")
    return ConversationHandler.END

async def handle_quiz_answer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.message.from_user.id
    user_data = context.application.user_data.get(user_id, {})

    if not user_data.get('quiz_active', False):
        return

    user_answer = update.message.text.strip()
    correct_answer = user_data.get('current_answer')

    if user_answer == correct_answer:
        await update.message.reply_text("✅ صحیح!")
    else:
        user_data['wrong_answers'] = user_data.get('wrong_answers', 0) + 1
        await update.message.reply_text(f"❌ اشتباه! پاسخ صحیح {correct_answer} بود.")

    if user_data.get('wrong_answers', 0) >= 3:
        await update.message.reply_text("🚨 شما به ۳ سوال پاسخ اشتباه دادید. چالش به پایان رسید.")
        user_data.clear()
        return

    if user_data.get('questions_asked', 0) >= 5:
        await update.message.reply_text("🎉 تبریک! شما چالش را با موفقیت به پایان رساندید.")
        user_data.clear()
        return

    user_data['questions_asked'] = user_data.get('questions_asked', 0) + 1
    question_data = random.choice(MATH_QUESTIONS)
    user_data['current_answer'] = question_data["answer"]
    await update.message.reply_text(f"سوال بعدی:\n\n{question_data['question']}")

async def main() -> None:
    """Starts the bot and the background alarm checker."""
    application = Application.builder().token(TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("setalarm", set_alarm_command)],
        states={
            GET_TIME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_time_from_user)],
        },
        fallbacks=[CommandHandler("cancel", cancel_command)],
    )

    application.add_handler(conv_handler)
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_quiz_answer))

    await application.initialize()
    await application.start()
    await application.updater.start_polling()

    print("Starting background alarm checker...")
    asyncio.create_task(alarm_checker(application))

    print("Bot is running...")
    # This loop keeps the script alive.
    while True:
        await asyncio.sleep(3600)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("Bot stopped manually.")