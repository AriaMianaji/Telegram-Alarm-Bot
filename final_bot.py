# -*- coding: utf-8 -*-
"""final bot

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rSjdNyEVzQN80fG8RkaHcGWREi8RURcV
"""

import logging
import os
import random
from datetime import datetime, time
import pytz
import asyncio

from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

# --- Configuration ---
# Reads the token from the server's environment variables
TOKEN = "TELEGRAM_BOT_TOKEN"
BOT_TIMEZONE = pytz.timezone("Asia/Tehran")

# --- Constants ---
GET_TIME = 0 # State for the conversation

# --- Logging Setup ---
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Question Repository ---
def generate_questions():
    """Generates a list of 100 simple-to-intermediate math questions in Farsi."""
    questions = []
    for _ in range(40):
        a, b = random.randint(10, 150), random.randint(10, 150)
        questions.append({"question": f"ðŸ§  Ø­Ø§ØµÙ„ {a} + {b} Ú†ÛŒØ³ØªØŸ", "answer": str(a + b)})
    for _ in range(30):
        a, b = random.randint(2, 12), random.randint(3, 15)
        questions.append({"question": f"ðŸ§  Ø­Ø§ØµÙ„ {a} Ã— {b} Ú†ÛŒØ³ØªØŸ", "answer": str(a * b)})
    for _ in range(30):
        a, b, c = random.randint(2, 10), random.randint(2, 10), random.randint(10, 50)
        questions.append({"question": f"ðŸ§  Ø­Ø§ØµÙ„ ({a} Ã— {b}) + {c} Ú†ÛŒØ³ØªØŸ", "answer": str(a * b + c)})
    random.shuffle(questions)
    return questions

MATH_QUESTIONS = generate_questions()

# --- ALARM CHECKER LOGIC ---
async def send_quiz_challenge(chat_id: int, context: ContextTypes.DEFAULT_TYPE):
    """Starts the quiz for a specific user."""
    user_id = chat_id
    user_specific_data = context.application.user_data[user_id]

    user_specific_data['quiz_active'] = True
    user_specific_data['questions_asked'] = 1
    user_specific_data['wrong_answers'] = 0

    question_data = random.choice(MATH_QUESTIONS)
    user_specific_data['current_answer'] = question_data["answer"]

    await context.bot.send_message(
        chat_id=chat_id,
        text=f"â° ÙˆÙ‚Øª Ø¨ÛŒØ¯Ø§Ø± Ø´Ø¯Ù† Ø§Ø³Øª! Ø¨Ù‡ Ø§ÛŒÙ† Ø³ÙˆØ§Ù„ Ù¾Ø§Ø³Ø® Ø¯Ù‡ÛŒØ¯:\n\n{question_data['question']}"
    )

async def alarm_checker(application: Application):
    """This task runs in the background, checking the time every minute."""
    while True:
        now = datetime.now(BOT_TIMEZONE)
        current_time_str = now.strftime("%H:%M")

        if alarms_to_trigger := application.bot_data.get(current_time_str, []):
            print(f"DEBUG: Found alarms for {current_time_str}!")
            for chat_id in alarms_to_trigger:
                asyncio.create_task(send_quiz_challenge(chat_id, ContextTypes.DEFAULT_TYPE(application, chat_id=chat_id)))

            application.bot_data[current_time_str] = []

        await asyncio.sleep(60)

# --- Core Bot Functions ---
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text("ðŸ‘‹ Ø¨Ù‡ Ø±Ø¨Ø§Øª Ø¢Ù„Ø§Ø±Ù…ÛŒ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯!\n\nØ¨Ø±Ø§ÛŒ ØªÙ†Ø¸ÛŒÙ… Ø¢Ù„Ø§Ø±Ù… Ø±ÙˆØ²Ø§Ù†Ù‡ Ø§Ø² Ø¯Ø³ØªÙˆØ± /setalarm Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.")

async def set_alarm_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Starts the conversation to set an alarm."""
    await update.message.reply_text("â° Ù„Ø·ÙØ§Ù‹ Ø³Ø§Ø¹Øª Ø¢Ù„Ø§Ø±Ù… Ø±Ø§ Ø¨Ø§ ÙØ±Ù…Øª HH:MM ÛŒØ§ H:MM Ø¨Ø±Ø§ÛŒ Ù…Ù† Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯ (Ù…Ø«Ù„Ø§Ù‹ 08:00 ÛŒØ§ 8:00).")
    return GET_TIME

async def get_time_from_user(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Saves an alarm after receiving the time from the user."""
    user_input = update.message.text.strip()
    chat_id = update.message.chat_id

    try:
        hour_str, minute_str = user_input.split(':')
        hour = int(hour_str)
        minute = int(minute_str)

        if not (0 <= hour <= 23 and 0 <= minute <= 59):
            raise ValueError("Time out of range.")

        alarm_time_str = f"{hour:02d}:{minute:02d}"

        if alarm_time_str not in context.bot_data:
            context.bot_data[alarm_time_str] = []

        if chat_id not in context.bot_data[alarm_time_str]:
            context.bot_data[alarm_time_str].append(chat_id)
            print(f"DEBUG: Alarm set for {chat_id} at {alarm_time_str}")
            await update.message.reply_text(f"âœ… Ù…ÙˆÙÙ‚ÛŒØª! Ø¢Ù„Ø§Ø±Ù… Ø´Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø¹Øª {alarm_time_str} (Ø¨Ù‡ ÙˆÙ‚Øª ØªÙ‡Ø±Ø§Ù†) ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯.")
        else:
            await update.message.reply_text("Ø´Ù…Ø§ Ù‚Ø¨Ù„Ø§Ù‹ ÛŒÚ© Ø¢Ù„Ø§Ø±Ù… Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø³Ø§Ø¹Øª ØªÙ†Ø¸ÛŒÙ… Ú©Ø±Ø¯Ù‡â€ŒØ§ÛŒØ¯.")

    except (ValueError, IndexError):
        await update.message.reply_text("âŒ ÙØ±Ù…Øª Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø§Ø² ÙØ±Ù…Øª HH:MM ÛŒØ§ H:MM Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯ (Ù…Ø«Ù„Ø§Ù‹ 07:45 ÛŒØ§ 7:45).")
        return GET_TIME

    return ConversationHandler.END

async def cancel_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancels the current conversation and clears any alarms."""
    chat_id = update.message.from_user.id
    for time_str, chat_ids in list(context.bot_data.items()):
        if chat_id in chat_ids:
            chat_ids.remove(chat_id)

    await update.message.reply_text("Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯ Ùˆ ØªÙ…Ø§Ù… Ø¢Ù„Ø§Ø±Ù…â€ŒÙ‡Ø§ÛŒ Ø´Ù…Ø§ Ù¾Ø§Ú© Ø´Ø¯.")
    return ConversationHandler.END

async def handle_quiz_answer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.message.from_user.id
    user_data = context.application.user_data.get(user_id, {})

    if not user_data.get('quiz_active', False):
        return

    user_answer = update.message.text.strip()
    correct_answer = user_data.get('current_answer')

    if user_answer == correct_answer:
        await update.message.reply_text("âœ… ØµØ­ÛŒØ­!")
    else:
        user_data['wrong_answers'] = user_data.get('wrong_answers', 0) + 1
        await update.message.reply_text(f"âŒ Ø§Ø´ØªØ¨Ø§Ù‡! Ù¾Ø§Ø³Ø® ØµØ­ÛŒØ­ {correct_answer} Ø¨ÙˆØ¯.")

    if user_data.get('wrong_answers', 0) >= 3:
        await update.message.reply_text("ðŸš¨ Ø´Ù…Ø§ Ø¨Ù‡ Û³ Ø³ÙˆØ§Ù„ Ù¾Ø§Ø³Ø® Ø§Ø´ØªØ¨Ø§Ù‡ Ø¯Ø§Ø¯ÛŒØ¯. Ú†Ø§Ù„Ø´ Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯.")
        user_data.clear()
        return

    if user_data.get('questions_asked', 0) >= 5:
        await update.message.reply_text("ðŸŽ‰ ØªØ¨Ø±ÛŒÚ©! Ø´Ù…Ø§ Ú†Ø§Ù„Ø´ Ø±Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³Ø§Ù†Ø¯ÛŒØ¯.")
        user_data.clear()
        return

    user_data['questions_asked'] = user_data.get('questions_asked', 0) + 1
    question_data = random.choice(MATH_QUESTIONS)
    user_data['current_answer'] = question_data["answer"]
    await update.message.reply_text(f"Ø³ÙˆØ§Ù„ Ø¨Ø¹Ø¯ÛŒ:\n\n{question_data['question']}")

async def main() -> None:
    """Starts the bot and the background alarm checker."""
    application = Application.builder().token(TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("setalarm", set_alarm_command)],
        states={
            GET_TIME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_time_from_user)],
        },
        fallbacks=[CommandHandler("cancel", cancel_command)],
    )

    application.add_handler(conv_handler)
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_quiz_answer))

    await application.initialize()
    await application.start()
    await application.updater.start_polling()

    print("Starting background alarm checker...")
    asyncio.create_task(alarm_checker(application))

    print("Bot is running...")
    # This loop keeps the script alive.
    while True:
        await asyncio.sleep(3600)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("Bot stopped manually.")